# Loads all the types of references in the database

CALL apoc.load.xml("file:///test.xml")
YIELD value

UNWIND [item in value._children] as entry

WITH entry,
	entry.key as key,
	entry.mdate as mdate,
	entry.publtype as publtype,
	entry.reviewid as reviewid,
	entry.rating as rating,
	entry.cdate as cdate,
	[item in entry._children WHERE item._type = "author"] AS authors,
	[item in entry._children WHERE item._type = "editor"] AS editors,
	[item in entry._children WHERE item._type = "title"][0] AS title,
	[item in entry._children WHERE item._type = "booktitle"][0] AS booktitle,
	[item in entry._children WHERE item._type = "pages"][0] AS pages,
	[item in entry._children WHERE item._type = "year"][0] AS year,
	[item in entry._children WHERE item._type = "address"][0] AS address,
	[item in entry._children WHERE item._type = "journal"] AS journals,
	[item in entry._children WHERE item._type = "year"][0] AS volume,
	[item in entry._children WHERE item._type = "year"][0] AS number,
	[item in entry._children WHERE item._type = "year"][0] AS month,
	[item in entry._children WHERE item._type = "url"][0] AS url,
	[item in entry._children WHERE item._type = "ee"][0] AS ee,
	[item in entry._children WHERE item._type = "cdrom"][0] AS cdrom,
	[item in entry._children WHERE item._type = "cite"] AS cites,
	[item in entry._children WHERE item._type = "publisher"][0] AS publisher,
	[item in entry._children WHERE item._type = "note"][0] AS note,
	[item in entry._children WHERE item._type = "crossref"][0] AS crossref,
	[item in entry._children WHERE item._type = "isbn"][0] AS isbn,
	[item in entry._children WHERE item._type = "series"][0] AS series,
	[item in entry._children WHERE item._type = "school"][0] AS school,
	[item in entry._children WHERE item._type = "chapter"][0] AS chapter,
	[item in entry._children WHERE item._type = "publnr"][0] AS publnr

CALL apoc.do.case([
	entry._type = "article","
					MERGE (a:Article {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.reviewid = reviewid
					SET a.rating = rating
					SET a.cdate = cdate
					RETURN a",
	entry._type = "inproceedings","
					MERGE (a:Inproceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "proceedings","
					MERGE (a:Proceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "book","
					MERGE (a:Book {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "incollection","
					MERGE (a:Incollection {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "phdthesis","
					MERGE (a:Phdthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "mastersthesis","
					MERGE (a:Mastersthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "www","
					MERGE (a:WWW {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "person","
					MERGE (a:Person {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "data","
					MERGE (a:Data {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a"],
	"MERGE(a:ERROR) RETURN a",
	{entry:entry, key:key, mdate:mdate, publtype:publtype, reviewid:reviewid, rating:rating, cdate:cdate}
)

YIELD value as a
WITH a.a AS a, authors, editors, title, booktitle, pages, year, address, journals, volume, number, month, url, ee, cdrom, cites, publisher, note, crossref, isbn, series, school, chapter, publnr

FOREACH(author in authors |
	MERGE (p:Person {name: author._text})
	MERGE (p)-[:author]->(a)
)


FOREACH (editor in editors |
	MERGE (p:Person {name: editor._text})
	MERGE (p)-[:editor]->(a)
)


SET a.title = title._text

SET a.booktitle = booktitle._text

SET a.pages = pages._text

MERGE (y:Year {value: year._text})
MERGE (a)-[:year]->(y)

//WIP
//MERGE (addr:Address {value: address._text})
//MERGE (a)-[:address]->(addr)

FOREACH(journal in journals |
	MERGE (j:Journal {name: journal._text})
	MERGE (j)-[:journal]->(a)
)

SET a.volume = volume._text

SET a.number = number._text

// month

SET a.url = url._text

SET a.ee = ee._text

SET a.cdrom = cdrom._text

// cites

// publisher

SET a.note = note._text

// crossref

SET a.isbn = isbn._text

SET a.series = series._text


// School

SET a.chapter = chapter._text

SET a.publnr = publnr._text


// WIP
//FOREACH(cite in cites |
//	MERGE (c:Citation {title: cite.label})
//	MERGE (a)-[:cite]->(c)
//)


Back up queries:

1. Type, authors number, occurence number

MATCH (n)-[a]-()
WHERE labels(n)[0] in ["article", "inproceedings", "proceedings", "book", "incollection", "phdthesis", "masterthesis", "www"]
with n, count(a) as ca
return labels(n)[0] as Type, ca as authors, count(n) as number
order by Type, authors


to do 

create (a:person:editor {editor : "a"}), 
	  (b:person:author {author : "a"}),
      (aa:person:editor {editor : "aa"}),
	  (bb:person:author {author : "aa"}), 
      (aaa:person:editor {editor : "aaa"}), 
      (bbb:person:author {author : "aaa"}), 
      (aaaa:person:editor {editor : "aaaa"}), (bbbb:person:author {author : "aaaa"}),
      (a)<-[:edited_by]-(:book {title : "1"}),
      (b)<-[:authored_by]-(:article {title : "1"}),
      (aa)<-[:edited_by]-(:book {title : "11"}),
      (bb)<-[:authored_by]-(:article {title : "11"}),
      (aaa)<-[:edited_by]-(:book {title : "111"}),
      (bbb)<-[:authored_by]-(:article {title : "111"}),
      (aaaa)<-[:edited_by]-(:book {title : "1111"}),
      (bbbb)<-[:authored_by]-(:article {title : "1111"})

MATCH (a1:editor), (a2:author)
where a1.editor = a2.author and not a1:author
WITH collect([a1,a2])[..1000] as n
unwind n as nodes
CALL apoc.refactor.mergeNodes(nodes,{
    properties:"combine",
    mergeRels:true
})
YIELD node
RETURN count(*)

