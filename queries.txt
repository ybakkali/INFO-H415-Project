# Loads all the types of references in the database

CALL apoc.load.xml("file:///test.xml")
YIELD value

UNWIND [item in value._children] as entry

WITH entry,
	entry.key as key,
	entry.mdate as mdate,
	entry.publtype as publtype,
	entry.reviewid as reviewid,
	entry.rating as rating,
	entry.cdate as cdate,
	[item in entry._children WHERE item._type = "author"] AS authors,
	[item in entry._children WHERE item._type = "editor"] AS editors,
	[item in entry._children WHERE item._type = "title"][0] AS title,
	[item in entry._children WHERE item._type = "booktitle"][0] AS booktitle,
	[item in entry._children WHERE item._type = "pages"][0] AS pages,
	[item in entry._children WHERE item._type = "year"][0] AS year,
	[item in entry._children WHERE item._type = "address"][0] AS address,
	[item in entry._children WHERE item._type = "journal"] AS journals,
	[item in entry._children WHERE item._type = "year"][0] AS volume,
	[item in entry._children WHERE item._type = "year"][0] AS number,
	[item in entry._children WHERE item._type = "year"][0] AS month,
	[item in entry._children WHERE item._type = "url"][0] AS url,
	[item in entry._children WHERE item._type = "ee"][0] AS ee,
	[item in entry._children WHERE item._type = "cdrom"][0] AS cdrom,
	[item in entry._children WHERE item._type = "cite"] AS cites,
	[item in entry._children WHERE item._type = "publisher"][0] AS publisher,
	[item in entry._children WHERE item._type = "note"][0] AS note,
	[item in entry._children WHERE item._type = "crossref"][0] AS crossref,
	[item in entry._children WHERE item._type = "isbn"][0] AS isbn,
	[item in entry._children WHERE item._type = "series"][0] AS series,
	[item in entry._children WHERE item._type = "school"][0] AS school,
	[item in entry._children WHERE item._type = "chapter"][0] AS chapter,
	[item in entry._children WHERE item._type = "publnr"][0] AS publnr

CALL apoc.do.case([
	entry._type = "article","
					MERGE (a:Article {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.reviewid = reviewid
					SET a.rating = rating
					SET a.cdate = cdate
					RETURN a",
	entry._type = "inproceedings","
					MERGE (a:Inproceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "proceedings","
					MERGE (a:Proceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "book","
					MERGE (a:Book {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "incollection","
					MERGE (a:Incollection {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "phdthesis","
					MERGE (a:Phdthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "mastersthesis","
					MERGE (a:Mastersthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "www","
					MERGE (a:WWW {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "person","
					MERGE (a:Person {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "data","
					MERGE (a:Data {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a"],
	"MERGE(a:ERROR) RETURN a",
	{entry:entry, key:key, mdate:mdate, publtype:publtype, reviewid:reviewid, rating:rating, cdate:cdate}
)

YIELD value as a
WITH a.a AS a, authors, editors, title, booktitle, pages, year, address, journals, volume, number, month, url, ee, cdrom, cites, publisher, note, crossref, isbn, series, school, chapter, publnr

FOREACH(author in authors |
	MERGE (p:Person {name: author._text})
	MERGE (p)-[:author]->(a)
)


FOREACH (editor in editors |
	MERGE (p:Person {name: editor._text})
	MERGE (p)-[:editor]->(a)
)


SET a.title = title._text

SET a.booktitle = booktitle._text

SET a.pages = pages._text

MERGE (y:Year {value: year._text})
MERGE (a)-[:year]->(y)

//WIP
//MERGE (addr:Address {value: address._text})
//MERGE (a)-[:address]->(addr)

FOREACH(journal in journals |
	MERGE (j:Journal {name: journal._text})
	MERGE (j)-[:journal]->(a)
)

SET a.volume = volume._text

SET a.number = number._text

// month

SET a.url = url._text

SET a.ee = ee._text

SET a.cdrom = cdrom._text

// cites

// publisher

SET a.note = note._text

// crossref

SET a.isbn = isbn._text

SET a.series = series._text


// School

SET a.chapter = chapter._text

SET a.publnr = publnr._text


// WIP
//FOREACH(cite in cites |
//	MERGE (c:Citation {title: cite.label})
//	MERGE (a)-[:cite]->(c)
//)



# 1. Give the number of publications for each type



# 2. Give the name of authors

MATCH (p:Person)-[:author]->()
RETURN p.name as Name


# 3. Give the names of authors who are also editors

MATCH ()<-[:editor]-(p:Person)-[:author]->()
RETURN p.name as Name


# 4. Give the authors ordered by the number of publications, in descending order

MATCH (p:Person)-[a:author]->()
WITH p, COUNT(a) as c ORDER BY c DESC
RETURN p.name as Name


# 5. Give the authors and the number of publications for each type


# 6. Give the author(s) having the highest number of publications

MATCH (p:Person)-[a:author]->()
WITH p, COUNT(a) as c
WITH max(c) as m
MATCH (p:Person)-[a:author]->()
WITH p, COUNT(a) as c, m
WHERE c = m
RETURN p.name as Name






