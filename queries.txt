# Loads all the types of references in the database

CALL apoc.load.xml("file:///test.xml")
YIELD value

UNWIND [item in value._children] as entry

WITH entry,
	entry.key as key,
	entry.mdate as mdate,
	entry.publtype as publtype,
	entry.reviewid as reviewid,
	entry.rating as rating,
	entry.cdate as cdate,
	[item in entry._children WHERE item._type = "author"] AS authors,
	[item in entry._children WHERE item._type = "editor"] AS editors,
	[item in entry._children WHERE item._type = "title"][0] AS title,
	[item in entry._children WHERE item._type = "booktitle"][0] AS booktitle,
	[item in entry._children WHERE item._type = "pages"][0] AS pages,
	[item in entry._children WHERE item._type = "year"][0] AS year,
	[item in entry._children WHERE item._type = "address"][0] AS address,
	[item in entry._children WHERE item._type = "journal"] AS journals,
	[item in entry._children WHERE item._type = "year"][0] AS volume,
	[item in entry._children WHERE item._type = "year"][0] AS number,
	[item in entry._children WHERE item._type = "year"][0] AS month,
	[item in entry._children WHERE item._type = "url"][0] AS url,
	[item in entry._children WHERE item._type = "ee"][0] AS ee,
	[item in entry._children WHERE item._type = "cdrom"][0] AS cdrom,
	[item in entry._children WHERE item._type = "cite"] AS cites,
	[item in entry._children WHERE item._type = "publisher"][0] AS publisher,
	[item in entry._children WHERE item._type = "note"][0] AS note,
	[item in entry._children WHERE item._type = "crossref"][0] AS crossref,
	[item in entry._children WHERE item._type = "isbn"][0] AS isbn,
	[item in entry._children WHERE item._type = "series"][0] AS series,
	[item in entry._children WHERE item._type = "school"][0] AS school,
	[item in entry._children WHERE item._type = "chapter"][0] AS chapter,
	[item in entry._children WHERE item._type = "publnr"][0] AS publnr

CALL apoc.do.case([
	entry._type = "article","
					MERGE (a:Article {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.reviewid = reviewid
					SET a.rating = rating
					SET a.cdate = cdate
					RETURN a",
	entry._type = "inproceedings","
					MERGE (a:Inproceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "proceedings","
					MERGE (a:Proceedings {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "book","
					MERGE (a:Book {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "incollection","
					MERGE (a:Incollection {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "phdthesis","
					MERGE (a:Phdthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "mastersthesis","
					MERGE (a:Mastersthesis {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "www","
					MERGE (a:WWW {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "person","
					MERGE (a:Person {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a",
	entry._type = "data","
					MERGE (a:Data {key: key})
					SET a.mdate = mdate
					SET a.publtype = publtype
					SET a.cdate = cdate
					RETURN a"],
	"MERGE(a:ERROR) RETURN a",
	{entry:entry, key:key, mdate:mdate, publtype:publtype, reviewid:reviewid, rating:rating, cdate:cdate}
)

YIELD value as a
WITH a.a AS a, authors, editors, title, booktitle, pages, year, address, journals, volume, number, month, url, ee, cdrom, cites, publisher, note, crossref, isbn, series, school, chapter, publnr

FOREACH(author in authors |
	MERGE (p:Person {name: author._text})
	MERGE (p)-[:author]->(a)
)


FOREACH (editor in editors |
	MERGE (p:Person {name: editor._text})
	MERGE (p)-[:editor]->(a)
)


SET a.title = title._text

SET a.booktitle = booktitle._text

SET a.pages = pages._text

MERGE (y:Year {value: year._text})
MERGE (a)-[:year]->(y)

//WIP
//MERGE (addr:Address {value: address._text})
//MERGE (a)-[:address]->(addr)

FOREACH(journal in journals |
	MERGE (j:Journal {name: journal._text})
	MERGE (j)-[:journal]->(a)
)

SET a.volume = volume._text

SET a.number = number._text

// month

SET a.url = url._text

SET a.ee = ee._text

SET a.cdrom = cdrom._text

// cites

// publisher

SET a.note = note._text

// crossref

SET a.isbn = isbn._text

SET a.series = series._text


// School

SET a.chapter = chapter._text

SET a.publnr = publnr._text


// WIP
//FOREACH(cite in cites |
//	MERGE (c:Citation {title: cite.label})
//	MERGE (a)-[:cite]->(c)
//)



# 1. Give the number of publications for each type

MATCH (n)
WHERE labels(n)[0] in ["article", "inproceedings", "proceedings", "book", "incollection", "phdthesis", "masterthesis", "www"]
RETURN labels(n) as Type, count(n) as Number

# 2. Give the name of authors

MATCH (a:author)<-[:authored_by]-()
RETURN DISTINCT a.author as Name


# 3. Give the names of authors who are also editors

MATCH ()-[:edited_by]->(a:author)<-[:authored_by]-()
RETURN a.author as Name


# 4. Give the authors ordered by the number of publications, in descending order

MATCH (p:author)<-[a:authored_by]-()
WITH p, COUNT(a) as c
ORDER BY c DESC
RETURN p.author as Name


# 5. Give the authors and the number of publications for each type

OPTIONAL MATCH (p:author)<--(a:article)
WITH p, COUNT(a) as ca

OPTIONAL MATCH (p)<--(b:inproceedings)
WITH p, ca, COUNT(b) as cb

OPTIONAL MATCH (p)<--(c:proceedings)
WITH p, ca, cb, COUNT(c) as cc

OPTIONAL MATCH (p)<--(d:book)
WITH p, ca, cb, cc, COUNT(d) as cd

OPTIONAL MATCH (p)<--(e:incollection)
WITH p, ca, cb, cc, cd, COUNT(e) as ce

OPTIONAL MATCH (p)<--(f:phdthesis)
WITH p, ca, cb, cc, cd, ce, COUNT(f) as cf

OPTIONAL MATCH (p)<--(g:mastersthesis)
WITH p, ca, cb, cc, cd, ce, cf, COUNT(g) as cg

OPTIONAL MATCH (p)<--(h:www)
WITH p, ca, cb, cc, cd, ce, cf, cg, COUNT(h) as ch

RETURN p.author as Author, ca as Article, cb as Inproceedings,
cc as Proceedings, cd as Book, ce as Incollection, cf as PHDThesis,
cg as MastersThesis, ch as WWW


# 6. Give the author(s) having the highest number of publications

MATCH (p:author)<-[a:authored_by]-()
WITH p, COUNT(a) as c
WITH max(c) as m
MATCH (p)<-[a]-()
WITH COUNT(a) as c, m
WHERE c = m
RETURN p.author as Name

MATCH (person:Person)-[:BOUGHT]->(food:FoodItem)
WITH person, food, count(food) as timesBought
WITH person, apoc.agg.maxItems(food, timesBought) as maxData
RETURN person, maxData.items as favoriteFoods, maxData.value as mostBoughtCount

MATCH (p:author)<-[a:authored_by]-(b)
WITH p, b, count(b) as c
WITH p, apoc.agg.maxItems(b, c) as m
RETURN p.author


7. Give for each author the total number of publications and the number of publications by type

MATCH (p:author)

OPTIONAL MATCH (p)<-[:authored_by]-(a:article)
WITH p, COUNT(a) as ca

OPTIONAL MATCH (p)<-[:authored_by]-(b:inproceedings)
WITH p, ca, COUNT(b) as cb

OPTIONAL MATCH (p)<-[:authored_by]-(c:proceedings)
WITH p, ca, cb, COUNT(c) as cc

OPTIONAL MATCH (p)<-[:authored_by]-(d:book)
WITH p, ca, cb, cc, COUNT(d) as cd

OPTIONAL MATCH (p)<-[:authored_by]-(e:incollection)
WITH p, ca, cb, cc, cd, COUNT(e) as ce

OPTIONAL MATCH (p)<-[:authored_by]-(f:phdthesis)
WITH p, ca, cb, cc, cd, ce, COUNT(f) as cf

OPTIONAL MATCH (p)<-[:authored_by]-(g:mastersthesis)
WITH p, ca, cb, cc, cd, ce, cf, COUNT(g) as cg

OPTIONAL MATCH (p)<-[:authored_by]-(h:www)
WITH p, ca, cb, cc, cd, ce, cf, cg, COUNT(h) as ch

WITH p, ca, cb, cc, cd, ce, cf, cg, ch, ca+cb+cc+cd+ce+cf+cg+ch as Total

RETURN p.author as Author, ca as Article, cb as Inproceedings,
cc as Proceedings, cd as Book, ce as Incollection, cf as PHDThesis,
cg as MastersThesis, ch as WWW, Total



8. Give the list of proceedings that have at least one editor that is also author of at least one article in the proceedings



9. Give for each author the number of co-authors and the number of joint publications with each of them

MATCH (p1:author)<-[:authored_by]-(a)-[:authored_by]->(p2:author)
WHERE p1 <> p2
WITH p1, p2, collect(a.title) as publications
RETURN p1.author as Author_1, p2.author as Author_2, SIZE(publications) as Number, publications as Publications


10. Give the distance of author "Hector Garcia-Molina" with respect to other authors. Two authors that write together a publication have distance 0. If an author a write a publication with author b and if author b write a publication with author c, then a is at distance 1 from c if a and c have not published together

MATCH (a1:author{author:"Hector Garcia-Molina"}), (a2:author)
WHERE a1 <> a2
MATCH p = ShortestPath((a1)-[:authored_by *]-(a2))
RETURN a1.author as Author_1, a2.author as Author_2, length(p)/2-1 as Distance


11. Give the number of publications by school

MATCH (s:school)-[]-(b)
RETURN s.school as School, COUNT(b) as Number


12. Give the number of publications by journal

MATCH (j:journal)-[]-(p)
RETURN j.journal as Journal, COUNT(p) as Number


13. Give the most prolific authors by journals

MATCH (j:journal)-[:published_in]-(a)-[:authored_by]-(p:author)
WITH j, COUNT(a) as ca, p
WITH j, MAX(ca) as mca

MATCH (j)-[:published_in]-(b)-[:authored_by]-(p:author)
WITH j, mca, COUNT(b) as cb, p
WHERE cb = mca
RETURN j.journal as Journal, collect(p.author) as Authors, cb as Number


14. The number of publication that composed the series

MATCH (s:series)-[:is_part_of]-(p)
RETURN s.series as Series, COUNT(p) as Number ORDER BY Number DESC


15. The number of publication of each type that composed the series

MATCH (s:series)

OPTIONAL MATCH (s)<-[:is_part_of]-(a:article)
WITH s, COUNT(a) as ca

OPTIONAL MATCH (s)<-[:is_part_of]-(b:inproceedings)
WITH s, ca, COUNT(b) as cb

OPTIONAL MATCH (s)<-[:is_part_of]-(c:proceedings)
WITH s, ca, cb, COUNT(c) as cc

OPTIONAL MATCH (s)<-[:is_part_of]-(d:book)
WITH s, ca, cb, cc, COUNT(d) as cd

OPTIONAL MATCH (s)<-[:is_part_of]-(e:incollection)
WITH s, ca, cb, cc, cd, COUNT(e) as ce

OPTIONAL MATCH (s)<-[:is_part_of]-(f:phdthesis)
WITH s, ca, cb, cc, cd, ce, COUNT(f) as cf

OPTIONAL MATCH (s)<-[:is_part_of]-(g:mastersthesis)
WITH s, ca, cb, cc, cd, ce, cf, COUNT(g) as cg

OPTIONAL MATCH (s)<-[:is_part_of]-(h:www)
WITH s, ca, cb, cc, cd, ce, cf, cg, COUNT(h) as ch

WITH s, ca, cb, cc, cd, ce, cf, cg, ch, ca+cb+cc+cd+ce+cf+cg+ch as Total

RETURN s.series as Series, ca as Article, cb as Inproceedings,
cc as Proceedings, cd as Book, ce as Incollection, cf as PHDThesis,
cg as MastersThesis, ch as WWW, Total


16. The number of publications published by the publisher



17. The top 5 authors with the longest interval of time between their first and last publications

MATCH (a:author)
MATCH (a)<-[:authored_by]-(p)
WITH a, MIN(p.year) as minp
MATCH (a)<-[:authored_by]-(p)
WITH a, minp, MAX(p.year) as maxp
RETURN a.author as Author, maxp - minp as Interval ORDER BY Interval DESC LIMIT 5



18. The number of publications by year

MATCH (y:year)-[:published_in_year]-(p)
RETURN y.year as Year, COUNT(p) as Number ORDER BY y.year


19. The average number of authors by publication type

MATCH (n)-[a]-()
WHERE labels(n)[0] in ["article", "inproceedings", "proceedings", "book", "incollection", "phdthesis", "masterthesis", "www"]
with n, count(a) as ca
with n, ca, count(n) as cb
return labels(n)[0] as Type, sum(cb * ca) / sum(cb) as `Authors average`


20. Top 5 of the most cited articles

WIP

MATCH (c:cite)<-[a:has_citation]-()
WITH c, COUNT(a) as ca
MATCH (p)
WHERE p.key = c
RETURN p.title as Publication, ca as Number

Back up queries:

1. Type, authors number, occurence number

MATCH (n)-[a]-()
WHERE labels(n)[0] in ["article", "inproceedings", "proceedings", "book", "incollection", "phdthesis", "masterthesis", "www"]
with n, count(a) as ca
return labels(n)[0] as Type, ca as authors, count(n) as number
order by Type, authors


to do 

MATCH (a1:editor), (a2:author)
where a1.editor = a2.author
WITH head(collect([a1,a2])) as nodes
CALL apoc.refactor.mergeNodes(nodes,{properties:"combine", mergeRels:true}) yield node
return node
